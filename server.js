// Generated by CoffeeScript 1.6.3
(function() {
  var Crypto, Dns, Fs, Http, LimitStream, QueryString, RESTRICTED_IPS, Stream, Url, camo_hostname, content_length_limit, current_connections, debug_log, error_log, finish, four_oh_four, hexdec, logging_enabled, max_redirects, port, process_url, server, shared_key, socket_timeout, started_at, total_connections, version,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Fs = require('fs');

  Dns = require('dns');

  Url = require('url');

  Http = require('http');

  Crypto = require('crypto');

  QueryString = require('querystring');

  port = parseInt(process.env.PORT || 8081);

  version = "1.3.0";

  shared_key = process.env.CAMO_KEY || '0x24FEEDFACEDEADBEEFCAFE';

  max_redirects = process.env.CAMO_MAX_REDIRECTS || 4;

  camo_hostname = process.env.CAMO_HOSTNAME || "unknown";

  socket_timeout = process.env.CAMO_SOCKET_TIMEOUT || 10;

  logging_enabled = process.env.CAMO_LOGGING_ENABLED || "disabled";

  content_length_limit = parseInt(process.env.CAMO_LENGTH_LIMIT || 5242880, 10);

  debug_log = function(msg) {
    if (logging_enabled === "debug") {
      console.log("--------------------------------------------");
      console.log(msg);
      return console.log("--------------------------------------------");
    }
  };

  error_log = function(msg) {
    if (logging_enabled !== "disabled") {
      return console.error("[" + (new Date().toISOString()) + "] " + msg);
    }
  };

  RESTRICTED_IPS = /^((10\.)|(127\.)|(169\.254)|(192\.168)|(172\.((1[6-9])|(2[0-9])|(3[0-1]))))/;

  total_connections = 0;

  current_connections = 0;

  started_at = new Date;

  four_oh_four = function(resp, msg, url) {
    error_log("" + msg + ": " + ((url != null ? url.format() : void 0) || 'unknown'));
    resp.writeHead(404);
    return finish(resp, "Not Found");
  };

  finish = function(resp, str) {
    current_connections -= 1;
    if (current_connections < 1) {
      current_connections = 0;
    }
    return resp.connection && resp.end(str);
  };

  Stream = require('stream');

  LimitStream = (function(_super) {
    __extends(LimitStream, _super);

    function LimitStream(length) {
      LimitStream.__super__.constructor.call(this);
      this.remaining = length;
    }

    LimitStream.prototype._transform = function(chunk, encoding, cb) {
      if (this.remaining > 0) {
        if (this.remaining < chunk.length) {
          chunk = chunk.slice(0, this.remaining);
        }
        this.push(chunk);
        this.remaining -= chunk.length;
        if (this.remaining <= 0) {
          this.emit('length_limited');
          this.end();
        }
      }
      return cb();
    };

    LimitStream.prototype.write = function(chunk, encoding, cb) {
      if (this.remaining > 0) {
        return LimitStream.__super__.write.apply(this, arguments);
      } else {
        return false;
      }
    };

    return LimitStream;

  })(Stream.Transform);

  process_url = function(url, transferred_headers, resp, remaining_redirects) {
    var fetch_url;
    if (url.host == null) {
      return four_oh_four(resp, "Invalid host", url);
    }
    if (url.protocol === 'https:') {
      error_log("Redirecting https URL to origin: " + (url.format()));
      resp.writeHead(301, {
        'Location': url.format()
      });
      finish(resp);
      return;
    } else if (url.protocol !== 'http:') {
      four_oh_four(resp, "Unknown protocol", url);
      return;
    }
    Dns.lookup(url.hostname, function(err, address, family) {
      if (err) {
        return four_oh_four(resp, "No host found: " + err, url);
      }
      if (address.match(RESTRICTED_IPS)) {
        return four_oh_four(resp, "Hitting excluded IP", url);
      }
      return fetch_url(address, url, transferred_headers, resp, remaining_redirects);
    });
    return fetch_url = function(ip_address, url, transferred_headers, resp, remaining_redirects) {
      var queryPath, requestOptions, srcReq, _ref;
      queryPath = url.pathname;
      if (url.query != null) {
        queryPath += "?" + url.query;
      }
      transferred_headers.host = url.host;
      debug_log(transferred_headers);
      requestOptions = {
        hostname: url.hostname,
        port: (_ref = url.port) != null ? _ref : 80,
        path: queryPath,
        headers: transferred_headers
      };
      srcReq = Http.get(requestOptions, function(srcResp) {
        var content_length, is_finished, limit, newHeaders, newUrl;
        is_finished = true;
        debug_log(srcResp.headers);
        content_length = srcResp.headers['content-length'];
        if (content_length > content_length_limit) {
          srcResp.destroy();
          return four_oh_four(resp, "Content-Length exceeded", url);
        } else {
          newHeaders = {
            'content-type': srcResp.headers['content-type'],
            'cache-control': srcResp.headers['cache-control'] || 'public, max-age=31536000',
            'Camo-Host': camo_hostname,
            'X-Content-Type-Options': 'nosniff'
          };
          if (content_length != null) {
            newHeaders['content-length'] = content_length;
          }
          if (srcResp.headers['transfer-encoding']) {
            newHeaders['transfer-encoding'] = srcResp.headers['transfer-encoding'];
          }
          if (srcResp.headers['content-encoding']) {
            newHeaders['content-encoding'] = srcResp.headers['content-encoding'];
          }
          srcResp.on('end', function() {
            if (is_finished) {
              return finish(resp);
            }
          });
          srcResp.on('error', function() {
            if (is_finished) {
              return finish(resp);
            }
          });
          switch (srcResp.statusCode) {
            case 200:
              if (newHeaders['content-type'] && newHeaders['content-type'].slice(0, 5) !== 'image') {
                srcResp.destroy();
                four_oh_four(resp, "Non-Image content-type returned", url);
                return;
              }
              debug_log(newHeaders);
              resp.writeHead(srcResp.statusCode, newHeaders);
              limit = new LimitStream(content_length_limit);
              srcResp.pipe(limit);
              limit.pipe(resp);
              return limit.on('length_limited', function() {
                srcResp.destroy();
                return error_log("Killed connection at content_length_limit: " + (url.format()));
              });
            case 301:
            case 302:
            case 303:
            case 307:
              srcResp.destroy();
              if (remaining_redirects <= 0) {
                return four_oh_four(resp, "Exceeded max depth", url);
              } else if (!srcResp.headers['location']) {
                return four_oh_four(resp, "Redirect with no location", url);
              } else {
                is_finished = false;
                newUrl = Url.parse(srcResp.headers['location']);
                if (!((newUrl.host != null) && (newUrl.hostname != null))) {
                  newUrl.host = newUrl.hostname = url.hostname;
                  newUrl.protocol = url.protocol;
                }
                debug_log("Redirected to " + (newUrl.format()));
                return process_url(newUrl, transferred_headers, resp, remaining_redirects - 1);
              }
              break;
            case 304:
              srcResp.destroy();
              return resp.writeHead(srcResp.statusCode, newHeaders);
            default:
              srcResp.destroy();
              return four_oh_four(resp, "Origin responded with " + srcResp.statusCode, url);
          }
        }
      });
      srcReq.setTimeout(socket_timeout * 1000, function() {
        srcReq.abort();
        return four_oh_four(resp, "Socket timeout", url);
      });
      srcReq.on('error', function() {
        return finish(resp);
      });
      resp.on('close', function() {
        error_log("Request aborted");
        return srcReq.abort();
      });
      return resp.on('error', function(e) {
        error_log("Request error: " + e);
        return srcReq.abort();
      });
    };
  };

  hexdec = function(str) {
    var buf, i, _i, _ref;
    if (str && str.length > 0 && str.length % 2 === 0 && !str.match(/[^0-9a-f]/)) {
      buf = new Buffer(str.length / 2);
      for (i = _i = 0, _ref = str.length; _i < _ref; i = _i += 2) {
        buf[i / 2] = parseInt(str.slice(i, +(i + 1) + 1 || 9e9), 16);
      }
      return buf.toString();
    }
  };

  server = Http.createServer(function(req, resp) {
    var dest_url, encoded_url, hmac, hmac_digest, query_digest, transferred_headers, url, url_type, user_agent, _base, _ref, _ref1;
    if (req.method !== 'GET' || req.url === '/') {
      resp.writeHead(200);
      return resp.end('hwhat');
    } else if (req.url === '/favicon.ico') {
      resp.writeHead(200);
      return resp.end('ok');
    } else if (req.url === '/status') {
      resp.writeHead(200);
      return resp.end("ok " + current_connections + "/" + total_connections + " since " + (started_at.toString()));
    } else {
      total_connections += 1;
      current_connections += 1;
      url = Url.parse(req.url);
      user_agent = (_base = process.env).CAMO_HEADER_VIA || (_base.CAMO_HEADER_VIA = "Camo Asset Proxy " + version);
      transferred_headers = {
        'Via': user_agent,
        'User-Agent': user_agent,
        'Accept': (_ref = req.headers.accept) != null ? _ref : 'image/*',
        'Accept-Encoding': req.headers['accept-encoding'],
        'x-content-type-options': 'nosniff'
      };
      delete req.headers.cookie;
      _ref1 = url.pathname.replace(/^\//, '').split("/", 2), query_digest = _ref1[0], encoded_url = _ref1[1];
      if (encoded_url = hexdec(encoded_url)) {
        url_type = 'path';
        dest_url = encoded_url;
      } else {
        url_type = 'query';
        dest_url = QueryString.parse(url.query).url;
      }
      debug_log({
        type: url_type,
        url: req.url,
        headers: req.headers,
        dest: dest_url,
        digest: query_digest
      });
      if (req.headers['via'] && req.headers['via'].indexOf(user_agent) !== -1) {
        return four_oh_four(resp, "Requesting from self");
      }
      if ((url.pathname != null) && dest_url) {
        hmac = Crypto.createHmac("sha1", shared_key);
        hmac.update(dest_url, 'utf8');
        hmac_digest = hmac.digest('hex');
        if (hmac_digest === query_digest) {
          url = Url.parse(dest_url);
          return process_url(url, transferred_headers, resp, max_redirects);
        } else {
          return four_oh_four(resp, "checksum mismatch " + hmac_digest + ":" + query_digest);
        }
      } else {
        return four_oh_four(resp, "No pathname provided on the server");
      }
    }
  });

  console.log("SSL-Proxy running on " + port + " with pid:" + process.pid + ".");

  console.log("Using the secret key " + shared_key);

  server.listen(port);

}).call(this);
